# 모던 리액트 딥 다이브: chapter1 [리액트 개발을 위해 꼭 알아야 할 자바스크립트]

## 1.1 자바스크립의 동등 비교

### 1.1.1 자바스크립트의 데이터 타입

- 원시 타입
  - boolean : 참과 거짓만을 가질 수 있는 데이터 타입, 참과 거짓과 같은 boolean 형의 값 외에도 조건문에서 참과 거짓으로 취급되는 truthy, falsy 값이 있다. ex(true, false, 1, 0, -1, 'hello', '', [], {}, null, undefined, NaN)
  - null : 값이 없음을 나타내는 값, 변수에 값이 없음을 명시적으로 할당할 때 사용한다.
  - undefined : 값이 할당되지 않은 상태를 나타내는 값, 변수 선언 이후 값이 할당되지 않은 상태를 의미한다.
  - number : 숫자를 나타내는 데이터 타입, 정수와 실수를 포함한다.
  - string : 문자열을 나타내는 데이터 타입, 문자열은 작은따옴표, 큰따옴표, 백틱으로 표현한다.
  - symbol : 유일한 값을 가지는 데이터 타입, 심볼은 다른 값과 중복되지 않는 유일한 값을 생성할 때 사용한다.
  - bigint : 2^53 - 1 보다 큰 정수를 나타내는 데이터 타입, 자바스크립트에서 정수를 표현하는 데이터 타입은 number이다.
- 객체 타입
  - object : 객체 타입은 참조를 전달한다고 해서 참조타입으로도 불린다.

### 1.1.2 값을 저장하는 방식의 차이

-원시 타입과 객체 타입의 가장큰 차이점은 값을 저장하는 방식의 차이이다. -원시 타입은 불변 형태의 값으로 저장, 변수 할당 시점에 메모리 영역을 차지하고 저장된다. -객체 타입은 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형테로 저장되며, 값을 복사할 떄도 값이 아닌 참조를 전달하게 된다.

-따라서 항상 객체 간에 비교가 발생하면, 이 객체 간의 비교는 우리가 이해하는 내부의 값이 같다 하더라도 결과는 대부분 true가 아닐 수 있다는 것을 인지해야한다.

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is

- ==과 ===가 만족하지 못하는 몇 가지 특이한 케이스를 추가하기 위해, Object.is가 나름의 알고리즘으로 작동하는 것을 알 수 있다. 주의해야 할점은 객체 비교에는 앞서 이야기안 원리와 동등하다.

### 1.1.4 리액트에서의 동등 비교

- 리액트에서는 동등 비교를 위해 Object.is를 사용한다. (30p, 코드 1.1) 이 Object.is를 기반으로 shallowEqual 함수를 만들어 의존성 비교 등 리액트의 동등 비교가 필요한 곳에서 사용한다. (31p, 코드 1.2)
- Object.is는 참조가 다른 객체에 대해 비교가 붉가능하다. shallowEqual은 객체의 1 depth 까지는 비교가 가능하다. 2 depth 이상의 객체는 비교가 불가능하다.

  -라액트에서 사용하는 JSX props는 객체이고 props만 일차적으로 비교하면 되기에 얕은 비교까지만 구현한다. 이러한 특성을 인지하고 있다면 props에 또 다른 객체를 넘겨준다면 리액트 렌더링이 예상치 못하게 작동한다는 것을 알 수 있다.

## 1.2 함수

- 리액트에서 함수 컴포넌트를 작성하다 보면 화살표 함수와 일반 함수를 혼재해서 쓰는 경우가 많은데 두 함수의 차이에 대해서는 정확히 모르는 경우가 많다. 함수의 다양한 형태와 이러한 함수의 차이점을 살펴보자

### 1.2.1 함수란 무엇인가?

- function으로 시작해 } 로 끝나는 부분까지가 함수를 정의한 부분이다. 리액트에서 컴포넌트를 만드는 함수도 이러한 기초적인 형태를 따르는것을 알 수 있다.

  ```
  function MyComponent(props) {
  return <div>Hello, {props.name}</div>;
  }
  ```

### 함수를 정의하는 4가지 방법

- 함수 선언문: 함수 선언문은 표현식이 아닌 일반 문으로 분류된다. 여기서 표현식이란 무언가 값을 산출하는 구문을 의미한다.
- 함수 표현식: 함수 표현식에 대해 알기 전에 일급 객체 라는 개념을 알고 있어야 한다. 일급 객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다. 자바스크립트에서 함수는 일급 객체이다. 그러므로 함수는 다른 함수의 매개변수, 반환값, 할당도 가능하다. 함수 표현식에서는 할당하려는 함수의 이름을 생략하는 것이 일반적이다.

  - *호이스팅*이란 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 특징이다.
  - 함수 선언문은 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을하여, 순서에 상관업시이 호출된다. 표현식은에서의 변수도 마찬가지로 호이스팅이 발생하지만 호이스팅이 되는 시점에서 undefined로 초기화된다.

- Function 생성자: 자바스크립트이 eval만큼이나 실제 코딩에서 사용되지 않는다.
- 화살표 함수: function이라는 키워드 대신 =>라는 화살표를 활용해서 함수를 만든다. 겉보기와 다르게 앞서 언급한 함수 생성 방식과 몇가지 큰 차이점이 있다. -화살표 함수에서는 constructor를 사용할 수 없다, 화살표 함수에서는 arguments 가 존재하지 않는다. 가장 큰 차이점은 this 바인딩이다. 일반함수로서 호출된다면 그 내부의 this는 전역 객체를 가리키지만
  화살표 함수는 함수 자체의 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 this를 사용하면 상위 스코프의 this를 가리킨다.

### 1.2.3 다양한 함수 살펴보기

- 즉시 실행 함수(IIFE): 함수 선언문을 즉시 실행하는 함수, 함수 선언문을 즉시 실행하는 함수이다. 단 한번만 호출되고, 다시금 호출할 수 없는 함수다.
- 고차 함수: 앞서 배운대로 자바스크립트의 함수가 일급 객체라는 특징을 활용하면 함수를 인수로 받거나 결과로 새로운 함수를 반환 시킬 수 있다. 이런 역할을 하는 함수를 고차함수라고 한다.

### 함수를 만들 때 주의해야 할 사항 (좋은 함수 만들기)

- 함수의 부수 효과를 최대한 억제하라. 부수효과(side -effect)란 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것을 의미한다. 부수효과가 존재하는 함수를 비순수함수 반대는 순수 함수이다. 웹 애플리케이션을 만드는 과정에서 부수 효과는 피할 수 없는 요소이다. 리액트 관점에서 본다면 부수 효과를 처리하는 훅인 useEffec의 작동을 최소화 하는것이 그 일환이다.
- 가능한 한 함수를 작게 만들어라 ESLint 에선 50줄이상 넘어가면 과도하게 커진함수라고 본다.
- 누구나 이해할 수 있는 이름을 붙여라

## 1.3 클래스

- 개발된 지 조금 오래된 애플리케이션이나 라이브러리를 마주한다면 클래스 컴포넌트를 보게 될 일도 종종 있을 것이다. 과거에 작성된 리액트 코드를 읽기 위해서, 또 이 코드를 함수 컴포넌트로만 작성할 예정이라 하더라라도 과거에 작성된 리액트 코드를 읽기 위해서, 이 코드를 함수 컴포넌트로 개선하기 위해서는 자바스크립트의 클래스가 어떤 식으로 작동하는지 이해햐아 한다.

### 1.3.1 클래스란 무엇인가?

- 자바스크립트의 클래스란 특정한 객체를 만들기 위한 일종의 템플릿과 같은 개념이다. (p48. 코드 1.8)
  -constructor 생성자: 객체를 생성하는데 사용한 특수한 메서드 여러 개를 사용한다면 에러가 발생하고 생략 가능하다. -프로퍼티: 인스턴스를 생성할 때 내부에 정의 할 수있는 속성값을 의미한다. -인스턴스 메서드: 클래스 내부에서 선언한 메서드를 인스턴스 메서드라고 한다. 이 인스턴스 메서드는 실제로 자바스크립트의 prototype에 선언된다. -정적 메소드: 특이하게 클래스의 인스턴가 아닌 이름으로 호출할 수 있는 메서드이다. 장작 메서드는 클래스 자신을 가리키기 때문에 this를 사용할 수 없다. -성속: 리액트에서 클래스 컴포넌트를 만들기위해 extends React.Component를 사용하는 것을 알 수 있다. 이 extends는 기존 클래스를 상속받아서 확장하는 개념이다.

## 1.3.2 클래스와 함수의 관계

- 클래스는 ES6에서 나온 개념으로 이전에는 프로토타입을 활용해 클래스의 작동 방식을 동일하게 구현 할 수 있었다.
